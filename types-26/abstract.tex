\documentclass{easychair}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{agda.fmt}%


\RequirePackage[T1]{fontenc}
\RequirePackage[utf8x]{inputenc}
\RequirePackage{ucs}
\RequirePackage{amsfonts}

\providecommand\mathbbm{\mathbb}

% TODO: Define more of these ...
\DeclareUnicodeCharacter{737}{\textsuperscript{l}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{8759}{::}
\DeclareUnicodeCharacter{9669}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}

% TODO: This is in general not a good idea.
\providecommand\textepsilon{$\epsilon$}
\providecommand\textmu{$\mu$}


%Actually, varsyms should not occur in Agda output.

% TODO: Make this configurable. IMHO, italics doesn't work well
% for Agda code.

\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
\let\Conid\Varid
\newcommand\Keyword[1]{\textsf{\textbf{#1}}}
\EndFmtInput






 







%%format [⇒] = "[\rightarrow]"
%%format ⊢ = "\vdash"
%%format _⊢_ = "\_\vdash\_"
























\usepackage{amssymb}

% use this if you have a long article and want to create an index
% \usepackage{makeidx}

% In order to save space or manage large tables or figures in a
% landscape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% Some of our commands for this guide.
%

%\makeindex

%% Front Matter
%%
% Regular title as in the article class.
%
\title{Containers in Higher Kinds}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%

\author{
  Thorsten Altenkirch\inst{1} \and
  H{\aa}kon Robbestad Gylterud\inst{2} \and
  Zhili Tian\inst{1}
}

\institute{
  $^{1}$School of Computer Science, University of Nottingham\\
  \email{\{psztxa,psxzt8\}@nottingham.ac.uk}\\
  $^{2}$Department of Informatics, University of Bergen\\
  \email{hakon.gylterud@uib.no}
}

%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Altenkirch, Gylterud, Tian}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair
\titlerunning{Containers in Higher Kinds}

\begin{document}

\maketitle

Strictly positive types can be represented as containers \cite{containers},
that is \ensuremath{\Conid{S}\;\mathbin{:}\;\Conid{Set}} and a family of positions \ensuremath{\Conid{P}\;\mathbin{:}\;\Conid{S}\;\rightarrow\;\Conid{Set}} giving rise to a
functor \ensuremath{\llbracket\;\Conid{S}\;\lhd\;\Conid{P}\;\rrbracket\;\mathbin{:}\;\Conid{Set}\;\Rightarrow\;\Conid{Set}}. Every container has an initial algebra
(The W-type) and a terminal coalgebra (The M-type). However, there are
inductive/coinductive types which do not fit the scheme of W-types/M-types.
An example of such a type is the inductive type \ensuremath{\Conid{Bush}}, defined as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Bush}\;(\Conid{A}\;\mathbin{:}\;\Conid{Set})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{[]}\;\mathbin{:}\;\Conid{Bush}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ::\char95 }\;\mathbin{:}\;\Conid{A}\;\rightarrow\;\Conid{Bush}\;(\Conid{Bush}\;\Conid{A})\;\rightarrow\;\Conid{Bush}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Even though \ensuremath{\Conid{Bush}\;\Conid{A}} is not a W-type, the type constructor \ensuremath{\Conid{Bush}} itself arises
as the initial algebra of a functor on a functor category\cite{bird1998nested,
bird1999generalised}. This motivates the development of a notion of containers
at higher kinds (such as \ensuremath{(\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;(\Varid{*}\;\Rightarrow\;\Varid{*})} or \ensuremath{(\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;\Varid{*}}) capable of modelling
strictly positive functors over containers.

\section*{Second-Order Containers}

We introduce a recursive syntax \ensuremath{\Conid{Cont}^{2}} by extending the \ensuremath{\Conid{Cont}} with a family
\ensuremath{\Conid{PF}\;\mathbin{:}\;\Conid{S}\;\rightarrow\;\Conid{Set}} of positions of \ensuremath{\Conid{F}} and an inductive continuation \ensuremath{\Conid{RF}\;\mathbin{:}\;(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\rightarrow\;\Conid{PF}\;\Varid{s}\;\rightarrow\;\Conid{Cont}^{2}}.
These, second order containers are of kind \ensuremath{(\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;(\Varid{*}\;\Rightarrow\;\Varid{*})}. Hence, each of them gives rise
to an endofunctor \ensuremath{\llbracket\;\Conid{S}\;\lhd\;\Conid{PX}\;\lhd\;\Conid{PF}\;\lhd\;\Conid{RF}\;\rrbracket\;\mathbin{:}\;\Conid{Cont}\;\Rightarrow\;\Conid{Cont}}. 

The \ensuremath{\Conid{Bush}} example can be specified using the following higher-order signature:
\ensuremath{\Conid{H}\;\Conid{F}\;\Conid{X}\;\mathrel{=}\;\Varid{1}\;\Varid{+}\;\Conid{X}\;\times\;\Conid{F}\;(\Conid{F}\;\Conid{X})}. There is a sum involved and therefore two shapes
(\ensuremath{\Conid{S}\;\mathrel{=}\;\Conid{Bool}}). The left shape is trivial with a constant, while in the right
shape, there is one position of \ensuremath{\Conid{X}} (\ensuremath{\Conid{PX}\;\Varid{true}\;\mathrel{=}\;\top}) and one position of
\ensuremath{\Conid{F}} (\ensuremath{\Conid{PF}\;\Varid{true}\;\mathrel{=}\;\top}). Finally, we need to model \ensuremath{\Conid{H'}\;\Conid{F}\;\Conid{X}\;\mathrel{=}\;\Conid{F}\;\Conid{X}} which proceeds
recursively (\ensuremath{\Conid{RF}\;\Varid{true}\;\Varid{tt}\;\mathrel{=}\;\Conid{H'}}).

We define a second-order least-fixpoint operator \ensuremath{\Conid{W}^{2}\;\mathbin{:}\;\Conid{Cont}^{2}\;\rightarrow\;\Conid{Cont}} by
induction-recursion, thereby recovering \ensuremath{\Conid{Bush}} as the initial algebra of
\ensuremath{\Conid{H}}. However, attempts to define a greatest fixpoint operator
\ensuremath{\Conid{M}^{2}\;\mathbin{:}\;\Conid{Cont}^{2}\;\rightarrow\;\Conid{Cont}} by coinduction-induction show a positivity issue.

\section*{Higher-Order Containers}

To continue the story of constructing strictly positive functors of functor
categories, we define a notion of higher container \ensuremath{\Conid{HCont}\;\mathbin{:}\;\Conid{Ty}\;\rightarrow\;\Conid{Set}}, where
\ensuremath{\Conid{Ty}} are just the types of simply typed $\lambda$-calculus with one base type
\ensuremath{\Varid{*}} which represents \ensuremath{\Conid{Set}}. \ensuremath{\Conid{HCont}} is just a special case of
\ensuremath{\Conid{Nf}\;\mathbin{:}\;\Conid{Con}\;\rightarrow\;\Conid{Ty}\;\rightarrow\;\Conid{Set}} where \ensuremath{\Conid{Con}} are the contexts of simply typed
$\lambda$-calculus \ensuremath{\Conid{HCont}\;\Conid{A}\;\mathrel{=}\;\Conid{Nf}\;\bullet\;\Conid{A}}. We also use \ensuremath{\Conid{Var}\;\mathbin{:}\;\Conid{Con}\;\rightarrow\;\Conid{Ty}\;\rightarrow\;\Conid{Set}}
for the typed de Bruijn variables. For brevity, we do not present the full
syntax. We remark that normal forms \ensuremath{\Conid{Nf}} are defined mutually with neutral terms
and spines, following the standard presentation of hereditary substitution for
simply typed $\lambda$-calculus\cite{keller2010normalization}. With this setting,
it is easy to see that \ensuremath{\Conid{Set}\;\cong\;\Conid{HCont}\;\Varid{*}}, \ensuremath{\Conid{Cont}\;\cong\;\Conid{HCont}\;(\Varid{*}\;\Rightarrow\;\Varid{*})} and
\ensuremath{\Conid{Cont}^{2}\;\cong\;\Conid{HCont}\;((\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;\Varid{*}\;\Rightarrow\;\Varid{*})}. 

We can interpret every higher container as a function on types, \ensuremath{\llbracket\_\rrbracket\;\mathbin{:}\;\Conid{HCont}\;\Conid{A}\;\rightarrow\;\llbracket\;\Conid{A}\;\rrbracket_{\mathrm{T}}} where \ensuremath{\llbracket\_\rrbracket_{\mathrm{T}}\;\mathbin{:}\;\Conid{Ty}\;\rightarrow\;\mathbf{Set}_1} is the obvious
interpretation of types (with \ensuremath{\llbracket\;\Varid{*}\;\rrbracket_{\mathrm{T}}\;\mathrel{=}\;\Conid{Set}}). We believe that this can
be extended to heredetary functors.
% We believe that this can
% be extended to heredetary functors. 
% \begin{code}
% record Cat (Obj : Set) : Set where
% record Func (C : Cat X) (D : Cat Y) (F : X → Y) : Set
% ⟦_⟧F : (A : Ty) → ⟦ A ⟧T → Set
% ⟦_⟧C : (A : Ty) → Cat (Σ ⟦ A ⟧T ⟦ A ⟧F)

% ⟦ * ⟧F X = Lift ⊤
% ⟦ A ⇒ B ⟧F H =
%   Σ[ HH ∈ ((F : ⟦ A ⟧T) → ⟦ A ⟧F F → ⟦ B ⟧F (H F)) ]
%   Func ⟦ A ⟧C ⟦ B ⟧C (λ (F , FF) → H F , HH F FF)
% \end{code}
% where |⟦_⟧T : Ty → Set| and |⟦_⟧C : Con → Set| are the interpretation
% of types and contexts in the intended model.
However, using this semantics
we can show that there is no third order fixed-point operators, \ensuremath{\Conid{W}^{3}}.
Consider the following higher order container
\footnote{This is the corresponding \ensuremath{\lambda}-term, the actual encoding is not very readable.}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{C}\;\mathbin{:}\;\Conid{HCont}\;(((\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;\Varid{*})\;\Rightarrow\;(\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;\Varid{*}){}\<[E]%
\\
\>[B]{}\Conid{C}\;\Conid{F}\;\Conid{G}\;\mathrel{=}\;\Conid{G}\;(\Conid{F}\;\Conid{G}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If an external fixpoint operator \ensuremath{\Conid{W}^{3}\;\mathbin{:}\;\Conid{HCont}\;(((\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;\Varid{*})\;\Rightarrow\;(\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;\Varid{*})\;\rightarrow\;\Conid{HCont}\;((\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;\Varid{*})}
exists, applying it to \ensuremath{\Conid{C}} leads to an internal fixpoint operator \ensuremath{\Varid{intW}\;\mathbin{:}\;\Conid{HCont}\;((\Varid{*}\;\Rightarrow\;\Varid{*})\;\Rightarrow\;\Varid{*})}.
According to the semantics, \ensuremath{\Varid{intW}\;\mathbin{:}\;(\Conid{Set}\;\Rightarrow\;\Conid{Set})\;\Rightarrow\;\Conid{Set}} gives a
fixpoint of any function n on types, but we know such thing does not
exist.

We would like to incorporate initial algebras and terminal coalgebras
at any type either by adding explicit fixpoint operators or by
allowing infinite terms (i.e. using a coinductively defined syntax)
In either case we will have to give up the naive semantics sketched
above. 

% for any type, which means that we 
% One approach to fixing this problem, is to add fixpoint operators (|μ and ν|) to our syntax and define
% an alternative semantics. The alternative we have in mind interprets higher containers |HCont (A ⇒ B)| as functors |HCont A ⇒ HCont B|. Applying the external fixpoint |W³| to |C| now gives rise to external
% |extW : HCont ((* ⇒ *) ⇒ *)|, which its semantics corresponds to exactly the usual fixed-point operator |W : Cont ⇒ Set|.

% Instead of adding the fixed point operators to the syntax explicitly, we could also add fixed-points
% implicitly by passing to a coinductive syntax with infinite terms. The semantics would then
% have to choose wether to interpret these as inductive or coinductive fixed points.

\section*{Higher containers as normalized $\lambda$-terms}

Furthermore, we show higher containers are normalized $\lambda$-terms
closed under arbitrary products and coproducts (maybe also under least-fixpoint and
greatest-fixpoint), together with a normalization function \ensuremath{\Varid{nf}\;\mathbin{:}\;\Conid{Tm}\;\Gamma\;\Conid{A}\;\rightarrow\;\Conid{Nf}\;\Gamma\;\Conid{A}}.

We also show \ensuremath{(\Conid{Con,}\;\Conid{Tms,}\;\Conid{Ty,}\;\Conid{Tm})} is a model of simply-typed
$\lambda$-calculus (STLC), where \ensuremath{\Conid{Tms}} is a list of \ensuremath{\Conid{Tm}}. Similarly, we hope
to prove that the normalized model \ensuremath{(\Conid{Con,}\;\Conid{Nfs,}\;\Conid{Ty,}\;\Conid{Nf})} is also a model of STLC, where
\ensuremath{\Conid{Nfs}} is a list of \ensuremath{\Conid{Nf}}.

%\newpage
\bibliographystyle{plain}
\bibliography{references}

%------------------------------------------------------------------------------

\end{document}
